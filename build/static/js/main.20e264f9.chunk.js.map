{"version":3,"sources":["api/index.js","components/Feature.js","components/Title.js","components/Preview.js","components/Search.js","index.js"],"names":["BASE_URL","KEY","fetchQueryResultsFromURL","url","a","fetch","response","json","data","fetchQueryResults","century","classification","queryString","fetchAllCenturies","localStorage","getItem","JSON","parse","records","setItem","stringify","fetchAllClassifications","Feature","props","setFeatured","Title","Preview","setSearchResults","setFeaturedResult","setIsLoading","info","searchResults","fetchPage","pageUrl","results","console","error","id","className","disabled","prev","onClick","next","map","record","index","key","event","preventDefault","primaryimageurl","src","alt","description","title","Search","useState","centuryList","setCenturyList","classificationList","setClassificationList","setQueryString","setCentury","setClassification","useEffect","Promise","all","then","log","onSubmit","result","htmlFor","type","placeholder","value","onChange","e","target","length","name","classificationItem","centuryItem","App","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.20e264f9.chunk.js","sourcesContent":["/**\n * This file features and exports all of your calls to the API\n * \n * You need to replace YOUR_API_KEY in the string associated with KEY with your actual API key\n */\nexport const BASE_URL = 'https://api.harvardartmuseums.org';\nexport const KEY = 'apikey=1ed6bd20-6ced-11ea-8bdc-95909fa24347'; // USE YOUR KEY HERE\n\n// prefetchCategoryLists();\n\n// function fetchUrl(url) {\n//   try {\n//     const data = await fetch(url);\n//     const response = await data.json();\n//     return response;\n//   } catch (err) {\n//     console.error(err.message);\n//   }\n// }\n\n// function fetchObjects() {\n//   const url = `${BASE_URL}/objects?${ KEY }`;\n//   return fetchUrl(url);\n// }\n\n// function fetchObjects() {\n//   const url = `${ BASE_URL })/object?${ KEY }`;\n\n//   fetch(url)\n//       .then(function (response) {\n//           return response.json()\n//       })\n//       .then(function (response) {\n//           console.log(response);\n//       })\n//       .catch(function (error) {\n//           console.error(error);\n//       });\n// }\n\n// fetchObjects();\n\n/**\n * This will make a call to the API for a single term and value (e.g. \"person\", and \"unknown\"), and return the result\n */\nexport async function fetchQueryResultsFromTermAndValue(term, value) {\n  try {\n    const response = await fetch(`${ BASE_URL }/object?${ KEY }&${ term }=${ encodeURI(value.split('-').join('|')) }`);\n    const data = await response.json();\n\n    return data;\n  } catch (error) {\n    throw error;\n  }\n}\n\n/**\n * This will make a call to the API for a preformed url (useful for previous and next buttons), and return the result\n */\nexport async function fetchQueryResultsFromURL(url) {\n  try {\n    const response = await fetch(url);\n    const data = await response.json();\n\n    return data;\n  } catch (error) {\n    throw error;\n  }\n}\n\n/**\n * Requires an object { century: '', classification: '', queryString: '' } to be passed in as an argument\n * \n * Then makes a call to the API, and returns the first page of results\n */\nexport async function fetchQueryResults({\n  century,\n  classification,\n  queryString,\n}) {\n  const url = `${ BASE_URL }/object?${ KEY }&classification=${ classification }&century=${ \n    century }&keyword=${ queryString }`;\n\n  try {\n    const response = await fetch(url);\n    const data = await response.json();\n\n    return data;\n  } catch (error) {\n    throw error;\n  }\n}\n\n/**\n * This returns early if there are centuries stored in localStorage, or fetches them from the API and stores them in localStorage if not\n */\nexport async function fetchAllCenturies() {\n  if (localStorage.getItem('centuries')) {\n    return JSON.parse(localStorage.getItem('centuries'));\n  }\n\n  const url = `${ BASE_URL }/century?${ KEY }&size=100&sort=temporalorder`;\n\n  try {\n    const response = await fetch(url);\n    const data = await response.json();\n    const records = data.records;\n\n    localStorage.setItem('centuries', JSON.stringify(records));\n\n    return records;\n  } catch (error) {\n    throw error;\n  }\n}\n\n/**\n * This returns early if there are classifications stored in localStorage, or fetches them from the API and stores them in localStorage if not \n */\nexport async function fetchAllClassifications() {\n  if (localStorage.getItem('classifications')) {\n    return JSON.parse(localStorage.getItem('classifications'));\n  }\n\n  const url = `${ BASE_URL }/classification?${ KEY }&size=100&sort=name`;\n\n  try {\n    const response = await fetch(url);\n    const data = await response.json();\n    const records = data.records;\n\n    localStorage.setItem('classifications', JSON.stringify(records));\n\n    return records;\n  } catch (error) {\n    throw error;\n  }\n}\n\n\n// this is new right here \n// async function prefetchCategoryLists() {\n// \ttry {\n// \t\tconst [classifications, centuries] = await Promise.all([\n// \t\t\tfetchAllClassifications(),\n// \t\t\tfetchAllCenturies(),\n// \t\t]);\n// \t\t// This provides a clue to the user, that there are items in the dropdown\n// \t\t$('.classification-count').text(`(${classifications.length})`);\n\n// \t\tclassifications.forEach((classification) => {\n// \t\t\t// append a correctly formatted option tag into\n// \t\t\t// the element with id select-classification\n// \t\t\t$('#select-classification')\n// \t\t\t\t.append(`<option value=\"${classification.name}\">${classification.name}</option>\n//   `);\n// \t\t});\n\n// \t\t// This provides a clue to the user, that there are items in the dropdown\n// \t\t$('.century-count').text(`(${centuries.length})`);\n\n// \t\tcenturies.forEach((century) => {\n// \t\t\t// append a correctly formatted option tag into\n// \t\t\t// the element with id select-century\n// \t\t\t$('#select-century')\n// \t\t\t\t.append(`<option value=\"${century.name}\">${century.name}</option>\n//   `);\n// \t\t});\n// \t} catch (error) {\n// \t\tconsole.error(error.message);\n// \t}\n// }","import React, { Fragment } from 'react';\n\n// Don't touch this import\nimport { fetchQueryResultsFromTermAndValue } from '../api';\n\n/**\n * We need a new component called Searchable which:\n * \n * Has a template like this:\n * \n * <span className=\"content\">\n *  <a href=\"#\" onClick={async (event) => {}}>SOME SEARCH TERM</a>\n * </span>\n *\n * You'll need to read searchTerm, searchValue, setIsLoading, and setSearchResults off of the props.\n * \n * When someone clicks the anchor tag, you should:\n * \n * - preventDefault on the event\n * - call setIsLoading, set it to true\n * \n * Then start a try/catch/finally block:\n * \n * try:\n *  - await the result of fetchQueryResultsFromTermAndValue, passing in searchTerm and searchValue\n *  - send the result to setSearchResults (which will update the Preview component)\n * catch: \n *  - console.error the error\n * finally:\n *  - call setIsLoading, set it to false\n */\n// const Searchable = (props) => {\n    //specifically the searchTerm and searchValue, as well as setIsLoading and setSearchResults.\n    // let searchTerm = searchTerm.props;\n    // let searchValue = searchValue.props;\n    // let setIsloading = setIsLoading.props;\n    // let setSearchResults = setSearchResults.props;\n//onClick should call fetchQueryResultsFromTermAndValue, and setSearchResults on the return of that call.\n// }\n\nconst Searchable = ({searchTerm, searchValue, setIsloading, setSearchResults}) => {\n    return  <span className=\"content\">\n      <a href=\"#\" onClick={async (event) => {\n          event.preventDefault();\n          setIsloading(true);\n      try {\n          const result = await fetchQueryResultsFromTermAndValue(searchTerm, searchValue);\n          setSearchResults(result);\n      } catch(error) {\n          console.error(error);\n      } finally {\n          setIsloading(false)\n      }\n      }}>{searchValue}</a>\n      </span>\n  }\n\n/**\n * We need a new component called Feature which looks like this when no featuredResult is passed in as a prop:\n * \n<main id=\"feature\"></main>\n * \n * And like this when one is:\n * \n  <main id=\"feature\">\n *   <div className=\"object-feature\">\n *     <header>\n *       <h3>OBJECT TITLE</h3>\n *       <h4>WHEN IT IS DATED</h4>\n *     </header>\n *     <section className=\"facts\">\n *       <span className=\"title\">FACT NAME</span>\n *       <span className=\"content\">FACT VALUE</span>\n *       <span className=\"title\">NEXT FACT NAME</span>\n *       <span className=\"content\">NEXT FACT VALUE</span>\n *     </section>\n *     <section className=\"photos\">\n *       <img src=IMAGE_URL alt=SOMETHING_WORTHWHILE />\n *     </section>\n *   </div>\n </main>\n * \n * The different facts look like this: title, dated, images, primaryimageurl, description, culture, style, \n * technique, medium, dimensions, people, department, division, contact, creditline\n * \n * The <Searchable /> ones are: culture, technique, medium (first toLowerCase it), and person.displayname (one for each PEOPLE)\n * \n * NOTE: people and images are likely to be arrays, and will need to be mapped over if they exist\n * \n * This component should be exported as default.\n */\nconst Feature = (props) => {\n    let setFeaturedResult = props.setFeatured\n\n\n}\n\nexport default Feature;","import React from 'react';\nimport { Title } from '.';\n\n/**\n * Create/export a component called Title which uses this static HTML as the template:\n * \n * <div id=\"title\">\n *   <h1>\n *     The Art Collector\n *   </h1>\n *   <h5>\n *     Search the Harvard Art Museums' Private Collections\n *   </h5>\n * </div>\n */\nexport default Title;\n","import React, { useState } from 'react';\n\n/**\n * We need to import fetchQueryResultsFromURL since we will sometimes have urls in info.prev and info.next\n * which are query urls.\n */\nimport { fetchQueryResultsFromURL } from '../api';\n\n\n\nconst Preview = (props) => {\n  // const { setSearchResults, setFeaturedResult, setIsLoading} = props;\n  let setSearchResults = setSearchResults.props;\n  let setFeaturedResult = setFeaturedResult.props;\n  let setIsLoading = setIsLoading.props;\n\n const searchResults = props.searchResults\n  let info = props.info\n  let records = props.records\n\n  // const {info, records, setSearchResults, setFeaturedResult, setIsLoading} = \n\n\n\n  /**\n   * Destructure setSearchResults, setFeaturedResult, and setIsLoading from props\n   * and also destructure info and records from props.searchResults\n   * \n   * You need info, records, setSearchResults, setFeaturedResult, and setIsLoading as available constants\n   */\n\n\n  /**\n   * Don't touch this function, it's good to go.\n   * \n   * It has to be defined inside the Preview component to have access to setIsLoading, setSearchResults, etc...\n   */\n  async function fetchPage(pageUrl) {\n    setIsLoading(true);\n\n    try {\n      const results = await fetchQueryResultsFromURL(pageUrl);\n      setSearchResults(results);\n    } catch (error) {\n      console.error(error);\n    } finally {\n      setIsLoading(false);\n    }\n  }\n\n  return <aside id=\"preview\">\n    <header className=\"pagination\">\n      {/* This button should be disabled if nothing is set in info.prev, and should call fetchPage with info.prev when clicked */}\n      <button \n        disabled={info.prev ? false : true} //added somefucntion in {} because it cannot be empty in JSX\n        className=\"previous\"\n        onClick={fetchPage(info.prev)}>Previous</button>\n      {/* This button should be disabled if nothing is set in info.next, and should call fetchPage with info.next when clicked */}\n      <button\n        disabled={info.next ? false : true}\n        className=\"next\"\n        onClick={fetchPage(info.next)}>Next</button>\n    </header>\n    <section className=\"results\">\n      \n        {records.map((record,index) => {\n          return (<div\n              key = {index}\n              className=\"object-preview\"\n              onClick={(event) =>{\n                event.preventDefault();\n                setFeaturedResult(true);\n              }}>\n                {record.primaryimageurl ? <img src={ record.primaryimageurl } alt={ record.description} /> : \"\" }\n                {record.title ? <h3>{ record.title }</h3> : <h3>MISSING INFO</h3>}\n              {/* if the record.primaryimageurl exists, show this: <img src={ record.primaryimageurl } alt={ record.description } />, otherwise show nothing  }\n              {if the record.title exists, add this: <h3>{ record.title }</h3>, otherwise show this: <h3>MISSING INFO</h3>} */}\n            </div>)  \n        })}\n    </section>\n  </aside>\n}\n\nexport default Preview;","import React, { useEffect, useState } from 'react';\n\n\n\n/**\n * Don't touch these imports!\n */\nimport { \n  fetchAllCenturies,\n  fetchAllClassifications,\n  fetchQueryResults\n} from '../api';\n\nconst Search = (props) => {\n\n  // Make sure to destructure setIsLoading and setSearchResults from the props\n    let setIsLoading = setIsLoading.props;\n    let setSearchResults = setSearchResults.props;\n\n  /**\n   * We are at the Search component, a child of app. This has a form, so we need to use useState for\n   * our controlled inputs:\n   * \n   * centuryList, setCenturyList (default should be an empty array, [])\n   * classificationList, setClassificationList (default should be an empty array, [])\n   * queryString, setQueryString (default should be an empty string, '')\n   * century, setCentury (default should be the string 'any')\n   * classification, setClassification (default should be the string 'any')\n   */\nconst [centuryList, setCenturyList] = useState([]);\nconst [classificationList, setClassificationList] = useState ([]);\nconst [queryString, setQueryString] = useState('');\nconst [century, setCentury] = useState('any');\nconst [classification, setClassification] = useState('any');\n\n\n  /**\n   * Inside of useEffect, use Promise.all([]) with fetchAllCenturies and fetchAllClassifications\n   * \n   * In the .then() callback pass the returned lists to setCenturyList and setClassificationList\n   * \n   * Make sure to console.error on caught errors from the API methods.\n   */\n  useEffect(() => {\n    try {\n      Promise.all([fetchAllCenturies(), fetchAllClassifications()])\n      .then(([century, classification]) => {\n        setCenturyList(century);\n        setClassificationList(classification);\n      })\n      \n    } catch (error) {\n      console.log(error);\n    }\n  }, []);\n  console.log(centuryList);\n  console.log(classificationList);\n\n  // try {\n  //   const centuryPromise = fetchAllcenturies();\n  //   const classificationPromise = fetchAllClassifications();\n  //   Promise.all([centuryPromise, classificationPromise]).then(([]) => {\n  //     // setCenturyList(values[0]);\n  //     // setClassificationList(values[1]);\n  //   })\n  // } catch (error) {\n  //   console.log(error);\n  // }\n\n  /**\n   * This is a form element, so we need to bind an onSubmit handler to it which:\n   * \n   * calls event.preventDefault()\n   * calls setIsLoading, set it to true\n   * \n   * then, in a try/catch/finally block:\n   * \n   * try to:\n   * - get the results from fetchQueryResults({ century, classification, queryString })\n   * - pass them to setSearchResults\n   * \n   * catch: error to console.error\n   * \n   * finally: call setIsLoading, set it to false\n   */\n  return <form id=\"search\" onSubmit={async (event) => {\n    // write code here\n    event.preventDefault();\n    setIsLoading(true);\n    try {\n      fetchQueryResults({century, classification, queryString})\n      .then(result => setSearchResults(result))\n    }\n    catch (error) {\n      console.error(error);\n    }\n    finally { setIsLoading(false);}\n  }}>\n    <fieldset>\n      <label htmlFor=\"keywords\">Query</label>\n      <input \n        id=\"keywords\" \n        type=\"text\" \n        placeholder=\"enter keywords...\" \n        value={queryString} \n        onChange={(e)=> {\n          setQueryString(e.target.value);\n        }}/>\n    </fieldset>\n    <fieldset>\n      <label htmlFor=\"select-classification\">Classification <span className=\"classification-count\">({ classificationList.length })</span></label>\n      <select \n        name=\"classification\"\n        id=\"select-classification\"\n        value={classification} \n        onChange={(e) => setClassification(e.target.value)}>\n        <option value=\"any\">Any</option>\n        {/* map over the classificationList, return an <option /> */}\n        {classificationList.map((classificationItem, index) => \n          <option value={classificationItem.name}key = {index}>{classification.name}</option>\n        )} \n      </select>\n    </fieldset>\n    <fieldset>\n      <label htmlFor=\"select-century\">Century <span className=\"century-count\">({ centuryList.length })</span></label>\n      <select \n        name=\"century\" \n        id=\"select-century\"\n        value={century} \n        onChange={(e) => setCentury(e.target.value)}>\n        <option value=\"any\">Any</option>\n        {/* map over the centuryList, return an <option /> */}\n        {centuryList.map((centuryItem,index) => \n           <option value={centuryItem.name}key = {index}>{centuryItem.name}</option> \n          )}\n      </select>\n     </fieldset>\n    <button>SEARCH</button>\n  </form>\n}\n\nexport default Search;","import React, { useState } from 'react';\nimport ReactDOM from 'react-dom';\n\n// These imports won't work until you fix ./components/index.js\nimport {\n  Feature,\n  Loading,\n  Preview,\n  Search,\n  Title\n} from './components';\n\n\nconst App = () => {\n  /**\n   * We are at the App level component, which is top-most. Any state which needs to be shared between immediate children should\n   * be made here, so create state pairs using useState() for:\n   * \n   * searchResults, setSearchResults (default should be this object:  {info: {}, records: []} )\n   * featuredResult, setFeaturedResult (default should be null)\n   * isLoading, setIsLoading (default should be false)\n   */\n\n  return <div className=\"app\">\n    {/* <Title /> is static, doesn't need any props */}\n    <Title />\n    {/* <Search /> needs props for setIsLoading and setSearchResults (trigger <Loading /> on search start/end, and transfer results to preview) */}\n    <Search />\n    {/* <Preview /> needs props for searchResults, setIsLoading and setSearchResults (clicking prev/next buttons), and setFeaturedResult (clicking a preview) */}\n    <Preview />\n    {/* <Feature /> needs props for featuredResult, as well as setIsLoading and setSearchResults (clicking on searchable properties) */}\n    <Feature />\n    {/* <Loading /> is static, but should only render when isLoading is true */}\n    <Loading /> {/* use a ternary and render null if isLoading is false */}\n  </div>\n}\n\n\nReactDOM.render(<App/>,document.getElementById(\"app\"));\n\n\n/**\n * Boostrap the <App /> component into the '#app' element in the DOM,\n * using ReactDOM.render();\n */"],"sourceRoot":""}